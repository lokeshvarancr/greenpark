// import React, { useState, useEffect, useMemo } from 'react';
// import {
//   BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, LineChart, Line, Legend, CartesianGrid
// } from 'recharts';
// import { ChevronUp, ChevronDown, TrendingUp, TrendingDown, Minus } from 'lucide-react';

// // Types
// interface DataRow {
//   id: number;
//   Institution: string;
//   Batch: string;
//   Class: string;
//   'Student Name': string;
//   Subject: string;
//   'Test Date': string;
//   'Correct Answers': number;
//   'Attempted Questions': number;
//   Score: number;
//   'Projected NEET Score': number;
//   Accuracy: number;
// }

// interface SubjectStat {
//   totalCorrect: number;
//   totalAttempted: number;
// }

// interface SubjectAccuracy {
//   Subject: string;
//   Accuracy: number;
//   'Total Attempted': number;
//   'Total Correct': number;
// }

// interface SubjectTrend {
//   'Test Date': string;
//   [subject: string]: number | string | null;
// }

// interface SubjectAverage {
//   Subject: string;
//   AverageScore: number;
// }

// interface Performer {
//   'Student Name': string;
//   Score: number;
//   Accuracy: number;
//   Class: string;
// }

// interface TopPerformerTable {
//   Subject: string;
//   Performers: Performer[];
// }

// interface RankImprover {
//   'Student Name': string;
//   Class: string;
//   Subject: string;
//   'Previous Test Date': string;
//   'Current Test Date': string;
//   'Previous Test Rank': number;
//   'Current Test Rank': number;
//   'Rank Change': number;
//   'Score Change': number;
//   'Percentile Shift': number;
// }

// interface SubjectImprovement {
//   Subject: string;
//   Improvement: number;
//   ShortTermTrend: number;
//   ShortTermTrendIcon: React.ReactNode;
//   ShortTermTrendColor: string;
// }

// interface ConsistentImprover {
//   'Student Name': string;
//   Class: string;
//   Subject: string;
//   'Test 1 Score': number;
//   'Test 2 Score': number;
//   'Test 3 Score': number;
//   'Cumulative Score Gain': number;
//   SparklineData: number[];
// }

// // Dummy Data Generation (Enhanced for more detailed test data)
// const generateDummyData = (): DataRow[] => {
//   const institutions = ['Green Park', 'Blue Hill', 'Oakwood'];
//   const batches = ['Alpha 2025', 'Beta 2024', 'Gamma 2023'];
//   const classes = ['12A', '12B', '11C'];
//   const subjects = ['Physics', 'Chemistry', 'Botany', 'Zoology'];
//   const studentNames = [
//     'Arjun Sharma', 'Priya Singh', 'Rahul Verma', 'Sneha Gupta', 'Vikram Reddy',
//     'Nisha Khan', 'Mohit Das', 'Sonia Jain', 'Alok Kumar', 'Deepa Nair',
//     'Kunal Patel', 'Divya Rao', 'Rohan Mishra', 'Meera Devi', 'Gaurav Yadav',
//     'Aisha Ahmed', 'Ben Carter', 'Chloe Davis', 'David Evans', 'Emily Foster',
//     'Frank Green', 'Grace Hall', 'Henry King', 'Ivy Lee', 'Jack Miller',
//     'Liam Brown', 'Olivia White', 'Noah Green', 'Emma Black', 'James Stone'
//   ];

//   // Generate more test dates for robust trend and rank analysis
//   const numTests = 8; // More tests to allow for consistent improvers over 3 tests
//   const testDates = Array.from({ length: numTests }, (_, i) => {
//     const d = new Date();
//     d.setDate(d.getDate() - (i * 25)); // Roughly every 25 days
//     return d.toISOString().split('T')[0];
//   }).reverse(); // Sort oldest to newest

//   const data: DataRow[] = [];
//   let id = 1;

//   institutions.forEach(institution => {
//     batches.forEach(batch => {
//       classes.forEach(_class => {
//         studentNames.forEach(studentName => {
//           subjects.forEach(subject => {
//             testDates.forEach(testDate => {
//               // Simulate score fluctuations for trends and rank changes
//               const baseScore = Math.floor(Math.random() * (120 - 40 + 1)) + 40; // Base score out of 180 (45 questions * 4 marks)
//               const scoreFluctuation = Math.floor(Math.random() * 20) - 10; // +/- 10 points
//               let score = baseScore + scoreFluctuation;
//               score = Math.max(0, Math.min(180, score)); // Keep score within 0-180 range (for 45 questions * 4 marks)

//               const correctAnswers = Math.round(score / 4);
//               const attemptedQuestions = Math.min(50, correctAnswers + Math.floor(Math.random() * 10)); // Attempted slightly more than correct
//               const accuracy = attemptedQuestions > 0 ? (correctAnswers / attemptedQuestions) * 100 : 0;
//               const projectedNeetScore = Math.floor(score * (720 / 180) + (Math.random() * 100 - 50)); // Scale to NEET range with some noise
//               const normalizedProjectedNeetScore = Math.max(100, Math.min(720, projectedNeetScore)); // Ensure within valid NEET range

//               data.push({
//                 id: id++,
//                 Institution: institution,
//                 Batch: batch,
//                 Class: _class,
//                 'Student Name': studentName,
//                 Subject: subject,
//                 'Test Date': testDate,
//                 'Correct Answers': correctAnswers,
//                 'Attempted Questions': attemptedQuestions,
//                 Score: score,
//                 'Projected NEET Score': parseFloat(normalizedProjectedNeetScore.toFixed(0)),
//                 Accuracy: parseFloat(accuracy.toFixed(2)),
//               });
//             });
//           });
//         });
//       });
//     });
//   });
//   return data;
// };

// const NeetEvaluationSection2: React.FC = () => {
//   const [rawData, setRawData] = useState<DataRow[]>([]);
//   const [selectedInstitution, setSelectedInstitution] = useState<string>('');
//   const [selectedBatch, setSelectedBatch] = useState<string>('');
//   const [selectedClass, setSelectedClass] = useState<string>('');
//   const [selectedSubjects, setSelectedSubjects] = useState<string[]>([]);
//   const [scoreRange, setScoreRange] = useState<[number, number]>([300, 700]); // Default full range

//   useEffect(() => {
//     setRawData(generateDummyData());
//   }, []);

//   // Extract unique filter options
//   const uniqueInstitutions = useMemo<string[]>(() => [...new Set(rawData.map(d => d.Institution))], [rawData]);
//   const uniqueBatches = useMemo<string[]>(() => [...new Set(rawData.map(d => d.Batch))], [rawData]);
//   const uniqueClasses = useMemo<string[]>(() => [...new Set(rawData.map(d => d.Class))], [rawData]);
//   const uniqueSubjects = useMemo<string[]>(() => [...new Set(rawData.map(d => d.Subject))], [rawData]);

//   // Filtered Data based on all slicers
//   const filteredData = useMemo<DataRow[]>(() => {
//     let currentData = rawData;

//     if (selectedInstitution) {
//       currentData = currentData.filter(d => d.Institution === selectedInstitution);
//     }
//     if (selectedBatch) {
//       currentData = currentData.filter(d => d.Batch === selectedBatch);
//     }
//     if (selectedClass) {
//       currentData = currentData.filter(d => d.Class === selectedClass);
//     }
//     if (selectedSubjects.length > 0) {
//       currentData = currentData.filter(d => selectedSubjects.includes(d.Subject));
//     }
//     currentData = currentData.filter(d =>
//       d['Projected NEET Score'] >= scoreRange[0] && d['Projected NEET Score'] <= scoreRange[1]
//     );

//     return currentData;
//   }, [rawData, selectedInstitution, selectedBatch, selectedClass, selectedSubjects, scoreRange]);

//   // --- Data for Visuals ---

//   // 1. Subject-Wise Accuracy Rate
//   const subjectAccuracyData = useMemo(() => {
//     const subjectStats: { [key: string]: SubjectStat } = {};
//     filteredData.forEach(d => {
//       if (!subjectStats[d.Subject]) {
//         subjectStats[d.Subject] = { totalCorrect: 0, totalAttempted: 0 };
//       }
//       subjectStats[d.Subject].totalCorrect += d['Correct Answers'];
//       subjectStats[d.Subject].totalAttempted += d['Attempted Questions'];
//     });

//     return Object.keys(subjectStats).map(subject => ({
//       Subject: subject,
//       Accuracy: subjectStats[subject].totalAttempted > 0 ?
//         parseFloat(((subjectStats[subject].totalCorrect / subjectStats[subject].totalAttempted) * 100).toFixed(2)) : 0,
//       'Total Attempted': subjectStats[subject].totalAttempted,
//       'Total Correct': subjectStats[subject].totalCorrect,
//     })).sort((a,b) => a.Subject.localeCompare(b.Subject)); // Sort alphabetically for consistency
//   }, [filteredData]);

//   // 2. Subject-Wise Score Trend Over Time
//   const subjectScoreTrendData = useMemo(() => {
//     const trendMap: { [key: string]: { [key: string]: { totalScore: number, count: number } } } = {}; // { TestDate: { Subject: { totalScore, count } } }

//     filteredData.forEach(d => {
//       if (!trendMap[d['Test Date']]) {
//         trendMap[d['Test Date']] = {};
//       }
//       if (!trendMap[d['Test Date']][d.Subject]) {
//         trendMap[d['Test Date']][d.Subject] = { totalScore: 0, count: 0 };
//       }
//       trendMap[d['Test Date']][d.Subject].totalScore += d.Score;
//       trendMap[d['Test Date']][d.Subject].count += 1;
//     });

//     const formattedTrendData = Object.keys(trendMap).sort().map(date => {
//       const entry: SubjectTrend = { 'Test Date': date };
//       uniqueSubjects.forEach(subject => { // Ensure all subjects are present for consistent lines
//         if (trendMap[date][subject]) {
//           entry[subject] = parseFloat((trendMap[date][subject].totalScore / trendMap[date][subject].count).toFixed(2));
//         } else {
//           entry[subject] = null; // No data for this subject on this date
//         }
//       });
//       return entry;
//     });
//     return formattedTrendData;
//   }, [filteredData, uniqueSubjects]);

//   // 3 & 4. Weakest and Strongest Subject Cards
//   const subjectAverageScores = useMemo(() => {
//     const subjectStats: { [key: string]: { totalScore: number, count: number } } = {};
//     filteredData.forEach(d => {
//       if (!subjectStats[d.Subject]) {
//         subjectStats[d.Subject] = { totalScore: 0, count: 0 };
//       }
//       subjectStats[d.Subject].totalScore += d.Score;
//       subjectStats[d.Subject].count += 1;
//     });

//     return Object.keys(subjectStats).map(subject => ({
//       Subject: subject,
//       AverageScore: parseFloat((subjectStats[subject].totalScore / subjectStats[subject].count).toFixed(2)),
//     }));
//   }, [filteredData]);

//   const weakestSubject = useMemo(() => {
//     if (subjectAverageScores.length === 0) return null;
//     return subjectAverageScores.reduce((min, current) => (current.AverageScore < min.AverageScore ? current : min));
//   }, [subjectAverageScores]);

//   const strongestSubject = useMemo(() => {
//     if (subjectAverageScores.length === 0) return null;
//     return subjectAverageScores.reduce((max, current) => (current.AverageScore > max.AverageScore ? current : max));
//   }, [subjectAverageScores]);

//   // 5. Top Performer by Subject Table - Modified to show top 5
//   const topPerformerTableData = useMemo(() => {
//     const subjectPerformers: { [key: string]: Performer[] } = {}; // { Subject: [ { Student Name, Score, Accuracy, Class } ] }

//     filteredData.forEach(d => {
//       if (!subjectPerformers[d.Subject]) {
//         subjectPerformers[d.Subject] = [];
//       }
//       subjectPerformers[d.Subject].push({
//         'Student Name': d['Student Name'],
//         Score: d.Score,
//         Accuracy: d.Accuracy,
//         Class: d.Class,
//       });
//     });

//     // Sort and get top 5 for each subject
//     return Object.keys(subjectPerformers).sort().map(subject => {
//       const performers = subjectPerformers[subject]
//         .sort((a, b) => {
//           // Sort by Score descending, then by Accuracy descending for ties
//           if (b.Score !== a.Score) {
//             return b.Score - a.Score;
//           }
//           return b.Accuracy - a.Accuracy;
//         })
//         .slice(0, 5); // Get top 5

//       return {
//         Subject: subject,
//         Performers: performers
//       };
//     });
//   }, [filteredData]);


//   // --- New Visuals ---

//   // Visual 1: Rank Improvers – Enhanced Table
//   const rankImproversData = useMemo(() => {
//     const studentSubjectTestHistory: { [key: string]: { 'Test Date': string, Score: number, 'Projected NEET Score': number, Class: string, Subject: string }[] } = {}; // { studentName_subject: [{ testDate, score, class }] }

//     // Group all test records by student and subject
//     rawData.forEach(d => { // Use rawData here to get full history for rank changes
//       const key = `${d['Student Name']}_${d.Subject}_${d.Class}`; // Include class in key to differentiate students with same name but different classes
//       if (!studentSubjectTestHistory[key]) {
//         studentSubjectTestHistory[key] = [];
//       }
//       studentSubjectTestHistory[key].push({
//         'Test Date': d['Test Date'],
//         Score: d.Score,
//         'Projected NEET Score': d['Projected NEET Score'],
//         Class: d.Class,
//         Subject: d.Subject,
//       });
//     });

//     const improvers: RankImprover[] = [];

//     // Calculate ranks per test and identify improvers
//     Object.keys(studentSubjectTestHistory).forEach(key => {
//       const history = studentSubjectTestHistory[key].sort((a, b) => new Date(a['Test Date']) - new Date(b['Test Date']));

//       if (history.length >= 2) { // Need at least two tests to calculate change
//         for (let i = 1; i < history.length; i++) {
//           const prevTest = history[i - 1];
//           const currTest = history[i];

//           // Simulate rank calculation for prevTest and currTest
//           // This is a simplification; in a real app, ranks would be pre-calculated or pulled from a rank system
//           // For dummy purposes, we'll calculate a 'simulated rank' based on their score relative to all scores on that test date.
//           // This will be very rough but demonstrates the concept.
//           const allScoresPrevTest = rawData.filter(d => d['Test Date'] === prevTest['Test Date'] && d.Subject === prevTest.Subject).map(d => d.Score);
//           const allScoresCurrTest = rawData.filter(d => d['Test Date'] === currTest['Test Date'] && d.Subject === currTest.Subject).map(d => d.Score);

//           const getRank = (score: number, allScores: number[]) => {
//             const sortedScores = [...new Set(allScores)].sort((a, b) => b - a); // Unique scores, highest first
//             return sortedScores.indexOf(score) + 1;
//           };

//           const prevRank = getRank(prevTest.Score, allScoresPrevTest);
//           const currentRank = getRank(currTest.Score, allScoresCurrTest);

//           const rankChange = prevRank - currentRank; // Positive if rank improved (number decreased)
//           const scoreChange = currTest.Score - prevTest.Score;

//           // Simulate percentile calculation based on current/previous projected NEET scores
//           // This is a very simple simulation of percentile shift.
//           const prevPercentile = prevTest['Projected NEET Score'] / 720 * 100;
//           const currentPercentile = currTest['Projected NEET Score'] / 720 * 100;
//           const percentileShift = parseFloat((currentPercentile - prevPercentile).toFixed(2));

//           if (rankChange > 0) { // Only show students whose current rank is better
//             improvers.push({
//               'Student Name': key.split('_')[0],
//               Class: currTest.Class,
//               Subject: currTest.Subject,
//               'Previous Test Date': prevTest['Test Date'], // Added for context
//               'Current Test Date': currTest['Test Date'], // Added for context
//               'Previous Test Rank': prevRank,
//               'Current Test Rank': currentRank,
//               'Rank Change': rankChange,
//               'Score Change': scoreChange,
//               'Percentile Shift': percentileShift,
//             });
//           }
//         }
//       }
//     });

//     // Apply global filters to the improvers data as well
//     let filteredImprovers = improvers;
//     if (selectedInstitution) {
//       filteredImprovers = filteredImprovers.filter(d => filteredData.some(fd => fd['Student Name'] === d['Student Name'] && fd.Institution === selectedInstitution));
//     }
//     if (selectedBatch) {
//       filteredImprovers = filteredImprovers.filter(d => filteredData.some(fd => fd['Student Name'] === d['Student Name'] && fd.Batch === selectedBatch));
//     }
//     if (selectedClass) {
//       filteredImprovers = filteredImprovers.filter(d => d.Class === selectedClass);
//     }
//     if (selectedSubjects.length > 0) {
//       filteredImprovers = filteredImprovers.filter(d => selectedSubjects.includes(d.Subject));
//     }
//     // Note: Score Range filter is tricky here as it applies to Projected NEET Score, not necessarily test scores,
//     // and would need to check if EITHER previous or current test's projected score is in range.
//     // For simplicity, will not apply projected NEET score filter to this table directly for now.

//     // Deduplicate by student-subject for latest improvement if multiple improvements occur
//     const latestImproversMap: { [key: string]: RankImprover } = {};
//     filteredImprovers.forEach(imp => {
//       const uniqueKey = `${imp['Student Name']}_${imp.Subject}`;
//       if (!latestImproversMap[uniqueKey] || new Date(imp['Current Test Date']) > new Date(latestImproversMap[uniqueKey]['Current Test Date'])) {
//         latestImproversMap[uniqueKey] = imp;
//       }
//     });

//     return Object.values(latestImproversMap).sort((a, b) => b['Rank Change'] - a['Rank Change']); // Sort by largest rank change
//   }, [rawData, selectedInstitution, selectedBatch, selectedClass, selectedSubjects, filteredData]);


//   // Visual 2: Subject Score Improvement % – Enhanced Diverging Bar Chart
//   const subjectImprovementData = useMemo(() => {
//     const improvementStats: { [key: string]: { scoresByDate: { [key: string]: { totalScore: number, count: number } } } } = {}; // { Subject: { firstScore: num, latestScore: num, scores: [num, num, ...], lastTestScore: num, secondLastTestScore: num } }

//     filteredData.forEach(d => {
//       if (!improvementStats[d.Subject]) {
//         improvementStats[d.Subject] = { scoresByDate: {} };
//       }
//       // Aggregate scores by date for average
//       if (!improvementStats[d.Subject].scoresByDate[d['Test Date']]) {
//         improvementStats[d.Subject].scoresByDate[d['Test Date']] = { totalScore: 0, count: 0 };
//       }
//       improvementStats[d.Subject].scoresByDate[d['Test Date']].totalScore += d.Score;
//       improvementStats[d.Subject].scoresByDate[d['Test Date']].count += 1;
//     });

//     return Object.keys(improvementStats).map(subject => {
//       const dates = Object.keys(improvementStats[subject].scoresByDate).sort();
//       if (dates.length === 0) return null;

//       const avgScores = dates.map(date => ({
//         date,
//         avgScore: improvementStats[subject].scoresByDate[date].totalScore / improvementStats[subject].scoresByDate[date].count
//       }));

//       const firstAvgScore = avgScores[0]?.avgScore || 0;
//       const latestAvgScore = avgScores[avgScores.length - 1]?.avgScore || 0;

//       const improvement = firstAvgScore !== 0 ? ((latestAvgScore - firstAvgScore) / firstAvgScore) * 100 : 0;

//       // Short-term trend (last test vs. previous test)
//       let shortTermTrend = 0;
//       let shortTermTrendIcon = <Minus className="w-4 h-4 text-gray-500" />;
//       let shortTermTrendColor = 'text-gray-500';

//       if (avgScores.length >= 2) {
//         const lastTestScore = avgScores[avgScores.length - 1].avgScore;
//         const prevTestScore = avgScores[avgScores.length - 2].avgScore;
//         shortTermTrend = lastTestScore - prevTestScore;

//         if (shortTermTrend > 0) {
//           shortTermTrendIcon = <TrendingUp className="w-4 h-4 text-green-600" />;
//           shortTermTrendColor = 'text-green-600';
//         } else if (shortTermTrend < 0) {
//           shortTermTrendIcon = <TrendingDown className="w-4 h-4 text-red-600" />;
//           shortTermTrendColor = 'text-red-600';
//         }
//       }

//       return {
//         Subject: subject,
//         Improvement: parseFloat(improvement.toFixed(2)),
//         ShortTermTrend: shortTermTrend, // Raw score delta
//         ShortTermTrendIcon: shortTermTrendIcon,
//         ShortTermTrendColor: shortTermTrendColor,
//       };
//     }).filter(Boolean).sort((a, b) => b.Improvement - a.Improvement); // Sort by improvement descending
//   }, [filteredData]);


//   // Visual 3: 3-Test Consistent Improvers – Enhanced Table
//   const consistentImproversData = useMemo(() => {
//     const studentSubjectScores: { [key: string]: { 'Test Date': string, Score: number }[] } = {}; // { studentName_class_subject: [ { testDate, score } ] }

//     // Group scores by student, class, and subject, sorted by test date
//     filteredData.forEach(d => {
//       const key = `${d['Student Name']}_${d.Class}_${d.Subject}`;
//       if (!studentSubjectScores[key]) {
//         studentSubjectScores[key] = [];
//       }
//       studentSubjectScores[key].push({
//         'Test Date': d['Test Date'],
//         Score: d.Score,
//       });
//     });

//     const consistentImprovers: ConsistentImprover[] = [];

//     Object.keys(studentSubjectScores).forEach(key => {
//       const history = studentSubjectScores[key].sort((a, b) => new Date(a['Test Date']) - new Date(b['Test Date']));
//       const [studentName, studentClass, subject] = key.split('_');

//       // Check for consistent improvement over the last 3 tests
//       if (history.length >= 3) {
//         const lastThreeTests = history.slice(-3); // Get the last three tests

//         const score1 = lastThreeTests[0].Score;
//         const score2 = lastThreeTests[1].Score;
//         const score3 = lastThreeTests[2].Score;

//         if (score2 > score1 && score3 > score2) { // Consistently increased
//           consistentImprovers.push({
//             'Student Name': studentName,
//             Class: studentClass,
//             Subject: subject,
//             'Test 1 Score': score1,
//             'Test 2 Score': score2,
//             'Test 3 Score': score3,
//             'Cumulative Score Gain': score3 - score1,
//             // Mini Trendline / Sparkline data (for demonstration, just the scores)
//             SparklineData: [score1, score2, score3],
//           });
//         }
//       }
//     });

//     return consistentImprovers.sort((a, b) => b['Cumulative Score Gain'] - a['Cumulative Score Gain']); // Sort by highest gain
//   }, [filteredData]);


//   const handleScoreRangeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
//     const value = parseInt(e.target.value, 10);
//     const id = e.target.id;
//     setScoreRange(prev => id === 'minScore' ? [value, prev[1]] : [prev[0], value]);
//   };

//   const handleSubjectChange = (subject: string) => {
//     setSelectedSubjects(prev =>
//       prev.includes(subject)
//         ? prev.filter(s => s !== subject)
//         : [...prev, subject]
//     );
//   };

//   const handleStudentDrillDown = (studentName: string) => {
//     console.log(`Simulating drill-down for student: ${studentName}`);
//     // In a real application, this would navigate to a student details page or open a modal.
//   };

//   return (
//     <div className="p-6 bg-gray-50 min-h-screen font-inter">
//       <h1 className="text-3xl font-bold text-gray-800 mb-6 text-center">NEET Evaluation Dashboard - Section 2</h1>

//       {/* Global Filters */}
//       <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-8 bg-white p-6 rounded-lg shadow-md">
//         <div>
//           <label htmlFor="institution" className="block text-sm font-medium text-gray-700 mb-1">Institution</label>
//           <select
//             id="institution"
//             className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
//             value={selectedInstitution}
//             onChange={(e) => setSelectedInstitution(e.target.value)}
//           >
//             <option value="">All Institutions</option>
//             {uniqueInstitutions.map(inst => (
//               <option key={inst} value={inst}>{inst}</option>
//             ))}
//           </select>
//         </div>

//         <div>
//           <label htmlFor="batch" className="block text-sm font-medium text-gray-700 mb-1">Batch</label>
//           <select
//             id="batch"
//             className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
//             value={selectedBatch}
//             onChange={(e) => setSelectedBatch(e.target.value)}
//           >
//             <option value="">All Batches</option>
//             {uniqueBatches.map(batch => (
//               <option key={batch} value={batch}>{batch}</option>
//             ))}
//           </select>
//         </div>

//         <div>
//           <label htmlFor="class" className="block text-sm font-medium text-gray-700 mb-1">Class</label>
//           <select
//             id="class"
//             className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
//             value={selectedClass}
//             onChange={(e) => setSelectedClass(e.target.value)}
//           >
//             <option value="">All Classes</option>
//             {uniqueClasses.map(_class => (
//               <option key={_class} value={_class}>{_class}</option>
//             ))}
//           </select>
//         </div>

//         <div>
//           <label className="block text-sm font-medium text-gray-700 mb-1">Subject</label>
//           <div className="mt-1 flex flex-wrap gap-2">
//             {uniqueSubjects.map(subject => (
//               <label key={subject} className="flex items-center">
//                 <input
//                   type="checkbox"
//                   className="form-checkbox h-4 w-4 text-indigo-600 transition duration-150 ease-in-out rounded"
//                   checked={selectedSubjects.includes(subject)}
//                   onChange={() => handleSubjectChange(subject)}
//                 />
//                 <span className="ml-2 text-sm text-gray-700">{subject}</span>
//               </label>
//             ))}
//           </div>
//         </div>

//         <div>
//           <label className="block text-sm font-medium text-gray-700 mb-1">Projected NEET Score Range</label>
//           <div className="flex items-center mt-1 gap-2">
//             <input
//               type="number"
//               id="minScore"
//               className="w-1/2 pl-3 pr-3 py-2 border border-gray-300 rounded-md text-sm"
//               value={scoreRange[0]}
//               onChange={handleScoreRangeChange}
//               min="0"
//               max="720"
//             />
//             <span className="text-gray-500">-</span>
//             <input
//               type="number"
//               id="maxScore"
//               className="w-1/2 pl-3 pr-3 py-2 border border-gray-300 rounded-md text-sm"
//               value={scoreRange[1]}
//               onChange={handleScoreRangeChange}
//               min="0"
//               max="720"
//             />
//           </div>
//         </div>
//       </div>

//       {/* 1. Subject-Wise Accuracy Rate (Top Visual) */}
//       <div className="bg-white p-6 rounded-lg shadow-md mb-8 w-full">
//         <h2 className="text-xl font-semibold text-gray-800 mb-4">Subject-Wise Accuracy Rate (%)</h2>
//         <ResponsiveContainer width="100%" height={300}>
//           <BarChart data={subjectAccuracyData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
//             <XAxis dataKey="Subject" className="text-sm" />
//             <YAxis label={{ value: 'Accuracy (%)', angle: -90, position: 'insideLeft', className: 'text-sm' }} />
//             <Tooltip
//               formatter={(value, name, props) => {
//                 if (name === "Accuracy") {
//                   return [`${value}%`, "Accuracy"];
//                 }
//                 return [value, name];
//               }}
//               labelFormatter={(label) => `Subject: ${label}`}
//               contentStyle={{ borderRadius: '8px', boxShadow: '0 2px 10px rgba(0,0,0,0.1)' }}
//             />
//             <Bar dataKey="Accuracy" fill="#4CAF50" radius={[10, 10, 0, 0]} /> {/* Green for accuracy */}
//           </BarChart>
//         </ResponsiveContainer>
//       </div>

//       {/* 2. Subject-Wise Score Trend Over Time */}
//       <div className="bg-white p-6 rounded-lg shadow-md mb-8 w-full">
//         <h2 className="text-xl font-semibold text-gray-800 mb-4">Subject-Wise Score Trend Over Time</h2>
//         <ResponsiveContainer width="100%" height={350}>
//           <LineChart data={subjectScoreTrendData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
//             <XAxis dataKey="Test Date" className="text-sm" />
//             <YAxis label={{ value: 'Average Score', angle: -90, position: 'insideLeft', className: 'text-sm' }} />
//             <Tooltip
//               formatter={(value, name, props) => {
//                 if (name === 'Test Date') return null; // Don't show "Test Date" in tooltip values
//                 return [`Avg Score: ${value}`, name];
//               }}
//               labelFormatter={(label) => `Date: ${label}`}
//               contentStyle={{ borderRadius: '8px', boxShadow: '0 2px 10px rgba(0,0,0,0.1)' }}
//             />
//             <Legend wrapperStyle={{ paddingTop: '10px' }} />
//             {uniqueSubjects.map((subject, index) => {
//               const colors = ['#8884d8', '#82ca9d', '#ffc658', '#ff7300']; // Distinct colors for lines
//               return <Line key={subject} type="monotone" dataKey={subject} stroke={colors[index % colors.length]} activeDot={{ r: 8 }} />;
//             })}
//           </LineChart>
//         </ResponsiveContainer>
//       </div>

//       {/* 3 & 4. Weakest and Strongest Subject Cards */}
//       <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
//         {/* Weakest Subject Card */}
//         <div className="bg-white p-6 rounded-lg shadow-md flex items-center justify-between transition duration-300 ease-in-out hover:shadow-lg">
//           <div className="flex items-center">
//             <div className="bg-red-100 p-3 rounded-full mr-4">
//               <ChevronDown className="h-6 w-6 text-red-600" />
//             </div>
//             <div>
//               <h3 className="text-lg font-semibold text-red-800">Weakest Subject</h3>
//               {weakestSubject ? (
//                 <p className="text-gray-700">
//                   <span className="font-bold">{weakestSubject.Subject}</span>
//                   : Avg Score <span className="font-semibold text-red-700">{weakestSubject.AverageScore}</span>
//                 </p>
//               ) : (
//                 <p className="text-gray-500">No data available</p>
//               )}
//             </div>
//           </div>
//         </div>

//         {/* Strongest Subject Card */}
//         <div className="bg-white p-6 rounded-lg shadow-md flex items-center justify-between transition duration-300 ease-in-out hover:shadow-lg">
//           <div className="flex items-center">
//             <div className="bg-green-100 p-3 rounded-full mr-4">
//               <ChevronUp className="h-6 w-6 text-green-600" />
//             </div>
//             <div>
//               <h3 className="text-lg font-semibold text-green-800">Strongest Subject</h3>
//               {strongestSubject ? (
//                 <p className="text-gray-700">
//                   <span className="font-bold">{strongestSubject.Subject}</span>
//                   : Avg Score <span className="font-semibold text-green-700">{strongestSubject.AverageScore}</span>
//                 </p>
//               ) : (
//                 <p className="text-gray-500">No data available</p>
//               )}
//             </div>
//           </div>
//         </div>
//       </div>

//       {/* 5. Top Performer by Subject Table */}
//       <div className="bg-white p-6 rounded-lg shadow-md w-full mb-8">
//         <h2 className="text-xl font-semibold text-gray-800 mb-4">Top 5 Performers by Subject</h2>
//         <div className="overflow-x-auto">
//           <table className="min-w-full divide-y divide-gray-200">
//             <thead className="bg-gray-50">
//               <tr>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider rounded-tl-lg">
//                   Subject
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Student Name
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Class
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Score
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider rounded-tr-lg">
//                   Accuracy (%)
//                 </th>
//               </tr>
//             </thead>
//             <tbody className="bg-white divide-y divide-gray-200">
//               {topPerformerTableData.length > 0 ? (
//                 topPerformerTableData.map((subjectGroup, subjectIndex) => (
//                   <React.Fragment key={subjectIndex}>
//                     {subjectGroup.Performers.map((row, rowIndex) => (
//                       <tr key={`${subjectGroup.Subject}-${rowIndex}`}>
//                         {/* Only display subject name once for the first student in the group */}
//                         {rowIndex === 0 ? (
//                           <td rowSpan={subjectGroup.Performers.length} className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900 border-r border-gray-200 align-top">
//                             {subjectGroup.Subject}
//                           </td>
//                         ) : null}
//                         <td className="px-6 py-4 whitespace-nowrap text-sm text-blue-600 hover:text-blue-800 cursor-pointer" onClick={() => handleStudentDrillDown(row['Student Name'])}>
//                           {row['Student Name']}
//                         </td>
//                         <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                           {row.Class}
//                         </td>
//                         <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                           {row.Score}
//                         </td>
//                         <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                           {row.Accuracy}%
//                         </td>
//                       </tr>
//                     ))}
//                   </React.Fragment>
//                 ))
//               ) : (
//                 <tr>
//                   <td colSpan="5" className="px-6 py-4 text-center text-sm text-gray-500">
//                     No data available for the current filters.
//                   </td>
//                 </tr>
//               )}
//             </tbody>
//           </table>
//         </div>
//       </div>

//       {/* New Visual 1: Rank Improvers – Enhanced Table */}
//       <div className="bg-white p-6 rounded-lg shadow-md w-full mb-8">
//         <h2 className="text-xl font-semibold text-gray-800 mb-4">Rank Improvers</h2>
//         <div className="overflow-x-auto">
//           <table className="min-w-full divide-y divide-gray-200">
//             <thead className="bg-gray-50">
//               <tr>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider rounded-tl-lg">
//                   Student Name
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Class
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Subject
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Prev Rank
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Curr Rank
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Δ Rank
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Δ Score
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   % Shift
//                 </th>
//               </tr>
//             </thead>
//             <tbody className="bg-white divide-y divide-gray-200">
//               {rankImproversData.length > 0 ? (
//                 rankImproversData.map((row, index) => (
//                   <tr key={index}>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-blue-600 hover:text-blue-800 cursor-pointer" onClick={() => handleStudentDrillDown(row['Student Name'])}>
//                       {row['Student Name']}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       {row.Class}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       {row.Subject}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       {row['Previous Test Rank']}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       {row['Current Test Rank']}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm font-semibold text-green-700">
//                       {row['Rank Change'] > 0 ? `-${row['Rank Change']}` : row['Rank Change']} {/* Rank improves when number decreases */}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       {row['Score Change'] > 0 ? `+${row['Score Change']}` : row['Score Change']}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       {row['Percentile Shift'] > 0 ? `+${row['Percentile Shift']}%` : `${row['Percentile Shift']}%`}
//                     </td>
//                   </tr>
//                 ))
//               ) : (
//                 <tr>
//                   <td colSpan="8" className="px-6 py-4 text-center text-sm text-gray-500">
//                     No rank improvers found for the current filters.
//                   </td>
//                 </tr>
//               )}
//             </tbody>
//           </table>
//         </div>
//       </div>

//       {/* New Visual 2: Subject Score Improvement % – Enhanced Diverging Bar Chart */}
//       <div className="bg-white p-6 rounded-lg shadow-md mb-8 w-full">
//         <h2 className="text-xl font-semibold text-gray-800 mb-4">Subject Score Improvement % (Long-term)</h2>
//         <ResponsiveContainer width="100%" height={300}>
//           <BarChart data={subjectImprovementData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
//             <CartesianGrid strokeDasharray="3 3" vertical={false} />
//             <XAxis dataKey="Subject" className="text-sm" />
//             <YAxis label={{ value: 'Improvement (%)', angle: -90, position: 'insideLeft', className: 'text-sm' }} />
//             <Tooltip
//               formatter={(value, name, props) => {
//                 if (name === "Improvement") {
//                   return [`${value}%`, "Long-term Improvement"];
//                 }
//                 return [value, name];
//               }}
//               labelFormatter={(label) => {
//                 const dataItem = subjectImprovementData.find(item => item.Subject === label);
//                 return `Subject: ${label} (Short-term trend: ${dataItem ? (dataItem.ShortTermTrend > 0 ? `+${dataItem.ShortTermTrend.toFixed(2)}` : dataItem.ShortTermTrend.toFixed(2)) : 'N/A'} score points)`;
//               }}
//               contentStyle={{ borderRadius: '8px', boxShadow: '0 2px 10px rgba(0,0,0,0.1)' }}
//             />
//             <Bar dataKey="Improvement" barSize={40} radius={[10, 10, 0, 0]}>
//               {subjectImprovementData.map((entry, index) => (
//                 <Bar key={`bar-${index}`} fill={entry.Improvement >= 0 ? "#4CAF50" : "#F44336"} />
//               ))}
//             </Bar>
//           </BarChart>
//         </ResponsiveContainer>
//         <div className="mt-4 flex flex-wrap justify-center gap-4 text-sm text-gray-700">
//           {subjectImprovementData.map((entry, index) => (
//             <div key={`legend-${index}`} className="flex items-center gap-1 p-2 bg-gray-100 rounded-md">
//               <span className="font-semibold">{entry.Subject}:</span>
//               <span className={`font-bold ${entry.Improvement >= 0 ? 'text-green-700' : 'text-red-700'}`}>{entry.Improvement}%</span>
//               <span className="ml-2">Short-term trend:</span>
//               <span className={`${entry.ShortTermTrendColor} font-semibold`}>
//                 {entry.ShortTermTrendIcon}
//                 {entry.ShortTermTrend > 0 ? `+${entry.ShortTermTrend.toFixed(2)}` : entry.ShortTermTrend.toFixed(2)}
//               </span>
//             </div>
//           ))}
//         </div>
//       </div>

//       {/* New Visual 3: 3-Test Consistent Improvers – Enhanced Table */}
//       <div className="bg-white p-6 rounded-lg shadow-md w-full">
//         <h2 className="text-xl font-semibold text-gray-800 mb-4">3-Test Consistent Improvers</h2>
//         <div className="overflow-x-auto">
//           <table className="min-w-full divide-y divide-gray-200">
//             <thead className="bg-gray-50">
//               <tr>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider rounded-tl-lg">
//                   Student Name
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Class
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Subject
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Test 1 Score
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Test 2 Score
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Test 3 Score
//                 </th>
//                 <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
//                   Cumulative Gain
//                 </th>
//                 {/* <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider rounded-tr-lg">
//                   Trend
//                 </th> */}
//               </tr>
//             </thead>
//             <tbody className="bg-white divide-y divide-gray-200">
//               {consistentImproversData.length > 0 ? (
//                 consistentImproversData.map((row, index) => (
//                   <tr key={index}>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-blue-600 hover:text-blue-800 cursor-pointer" onClick={() => handleStudentDrillDown(row['Student Name'])}>
//                       {row['Student Name']}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       {row.Class}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       {row.Subject}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       {row['Test 1 Score']}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       {row['Test 2 Score']}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       {row['Test 3 Score']}
//                     </td>
//                     <td className="px-6 py-4 whitespace-nowrap text-sm font-semibold text-green-700">
//                       +{row['Cumulative Score Gain']}
//                     </td>
//                     {/* Placeholder for Sparkline/Mini Trendline - can be added with a charting library if needed */}
//                     {/* <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
//                       <ResponsiveContainer width="100%" height={30}>
//                         <LineChart data={row.SparklineData.map(s => ({ score: s }))}>
//                           <Line type="monotone" dataKey="score" stroke="#8884d8" strokeWidth={2} dot={false} />
//                         </LineChart>
//                       </ResponsiveContainer>
//                     </td> */}
//                   </tr>
//                 ))
//               ) : (
//                 <tr>
//                   <td colSpan="7" className="px-6 py-4 text-center text-sm text-gray-500">
//                     No consistent improvers found for the current filters.
//                   </td>
//                 </tr>
//               )}
//             </tbody>
//           </table>
//         </div>
//       </div>

//     </div>
//   );
// };

// // Main App component to render the dashboard section
// const App: React.FC = () => {
//   return (
//     <NeetEvaluationSection2 />
//   );
// };

// export default App;
